/* * Remix Script Runner Configuration (Required before running!):
 * 1. Click the dropdown arrow next to the 'Run script' button in the top left of the editor.
 * 2. Select 'Open script configuration'.
 * 3. In the configuration modal or panel, choose 'Noir' as the execution environment.
 * 4. Close the configuration and then click 'Run script'.
 */
/* eslint-disable @typescript-eslint/no-var-requires */
const { expect } = require('chai');
import { UltraHonkBackend } from '@aztec/bb.js';

// A utility function to convert a hexadecimal string (with or without '0x' prefix) into a Uint8Array.
// bb.js requires proof data to be in a byte array format, not a string.
const hexToBytes = (hex) => {
  if (typeof hex !== 'string') {
    throw new Error('Input must be a string');
  }
  if (hex.startsWith('0x')) {
    hex = hex.slice(2);
  }
  if (hex.length % 2 !== 0) {
    hex = '0' + hex;
  }
  const bytes = new Uint8Array(hex.length / 2);
  for (let i = 0; i < bytes.length; i++) {
    bytes[i] = parseInt(hex.slice(i * 2, i * 2 + 2), 16);
  }
  return bytes;
};

describe('JS Verification of Backend Proof', () => {
  let backend;
  let proofBytes;
  let publicInputs;

  const BUILD_PATH = 'circuits/zkleanpool/build';

  before(async () => {
    console.log('Loading artifacts generated by the backend...');
    
    // Step 1: Load the compiled circuit artifact (`program.json`).
    // This file contains the essential `bytecode` needed to initialize the verifier backend.
    // We are using the result from the backend.
    const programJson = await remix.call('fileManager', 'readFile', BUILD_PATH + '/program.json');
    const circuit = JSON.parse(programJson);
    if (!circuit.bytecode) {
      throw new Error("program.json does not contain 'bytecode'.");
    }

    // Step 2: Load the proof and public inputs that were generated and formatted by the backend.
    // These are the specific artifacts we want to verify.
    const proofHex = await remix.call('fileManager', 'readFile', BUILD_PATH + '/proof');
    const publicInputsJson = await remix.call('fileManager', 'readFile', BUILD_PATH + '/public_inputs');

    // Step 3: Prepare the loaded data for use with bb.js.
    // The proof is converted from a hex string to bytes, and the public inputs are parsed from a JSON string.
    proofBytes = hexToBytes(proofHex);
    publicInputs = JSON.parse(publicInputsJson);
    
    console.log(`Proof size: ${proofBytes.length} bytes`);
    console.log(`Public inputs: ${publicInputs.length}`);

    // Step 4: Initialize the UltraHonkBackend with the circuit's bytecode.
    // This backend instance will perform the actual verification calculation.
    backend = new UltraHonkBackend(circuit.bytecode);
  });

  after(async () => {
    if (backend) {
      console.log('Destroying backend...');
      await backend.destroy();
    }
  });

  it('should verify the proof successfully', async () => {
    console.log('Verifying proof using bb.js...');
    
    // Step 5: Call the `verifyProof` method.
    // It takes an object containing the `proof` (as bytes) and `publicInputs`.
    // The `{ keccak: true }` option is crucial and must match the option used on the backend
    // when the proof was generated to ensure compatibility.
    const verified = await backend.verifyProof({ proof: proofBytes, publicInputs }, { keccak: true });
    
    console.log('---------------------------');
    console.log(`Verification result: ${verified}`);
    console.log('---------------------------');

    // Use the Chai `expect` function to assert that the verification result is true.
    // If `verified` is false, the test will fail and display the error message
    expect(verified, 'Proof fails verification in JS').to.be.true;
  });
});
